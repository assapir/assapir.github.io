---
title: בוקר טוב עולם
date: "2021-07-25"
tags: ["rust", "ראסט"]
---

התקנו את כל מה שצריך בשביל לכתוב קוד, והיום ממש ממש נכתוב קוד. כמקובל בענף, נתחיל עם התוכנית הידועה בה נדפיס "Hello World". גם כאן, קארגו יסייע לנו לעשות זאת בקלות. תחילה, נעבור לתיקיה בה נרצה ליצור את הפרויקט החדש שלנו. שימו לב: לא התיקיה בה הקוד שלנו יהיה, אלא התיקיה המכילה אותה. לדוגמה, אני אוהב לרכז את כל הקוד שלא קשור לעבודה שלי בתיקיה private תחת המשתמש שלי, ולכן זה מה שאעשה:
```shell
cd ~/private
```
ניצור פרויקט חדש באמצעות קרגו. נריץ:
```shell
cargo new hello_world
```
ונקבל בתגובה
```shell{outputLines: 1}{numberLines: 2}
Created binary (application) `hello_world` package
```
מעולה! קרגו יצר לנו את הבסיס לתוכנה שלנו. הוא יצא לנו תיקיה בשם `hello_world`, כי זה שם הפרויקט שהעברנו לקרגו כפרמטר. נכנס לתיקיה ונפתח את VSCODE:
```shell
cd hello_world
code .
```
כעת, אם נבחן את הפרויקט שלנו, נוכל לשים לב לכמה דברים בנוסף לתיקיה עצמה שקרגו יצר לנו. נתחיל מהקובץ `gitignore.`. זה לא המקום להרחיב, אבל זה יכול לרמוז לנו שהתיקיה שלנו היא כבר ריפוזיטורי של git. מעולה! נחסך לנו שלב אם וכאשר נרצה להעלות את הקוד שלנו לגיטהאב, או סתם יקל עלינו לנהל גרסאות שלו מקומית.

בנוסף, נוצר לנו גם קובץ בשם `Cargo.toml`. כפי ששם הקובץ מרמז, הוא משמש כקובץ הגדרות לקרגו בזמן שאנחנו בפרויקט, בדומה לקובץ `package.json` בפרויקטים של Node. הסיומת `toml` היא של סוג מידע שגם בני אדם וגם מחשבים יכולים לקרוא, ולקרוב משמש להגדרות, בדומה לקבצי `yaml` או `json`.
נפתח את הקובץ ונבחן אותו:
```toml
[package]
name = "hello_world"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
החלק הראשון, לאחר הכותרת `package` מכיל פרטים על החבילה שאנחנו נבנה: שם החבילה, גירסה שלה, ובאיזו גירסה של ראסט אנחנו נשתמש.
בחלק השני, לאחר הכותרת `dependency`, אין כרגע כלום, אך בעתיד נשתמש בה כדי לציין חבילות נוספות שנדרשות לפיתוח התוכנה שלנו. כרגע, אין לנו שום תלויות, ולכן החלק הזה ריק.

התיקיה החשובה יותר היא תיקיית `src`, קיצור של `source`. כאן נמצאת התוכנה שלנו ממש. שם נמצא קובץ בשם `main.rs`. כל חבילה של ראסט שתתקמפל לקובץ הרצה, **חייבת** להכיל קובץ בשם `main.rs`. משם הקומפיילר יודע מאיפה להתחיל. `rs` היא הסיומת לקבצים של ראסט. בתוך הקובץ נוכל לראות שכברירת מחדל, יש לנו כבר תוכנת "שלום עולם" מוכנה:
```rust
fn main() {
    println!("Hello, world!");
}
```
נעבור על הקובץ שורה שורה:
```rust
fn main() {
```
כפי שכל תוכנה של ראסט חייבת להכיל קובץ `main.rs`, כך גם הקובץ הזה חייב להכיל פונקציה בשם `main` (עוד על מה זה בדיוק פונקציות, בהמשך). ההצהרה על הפונקציה `main` נעשית באמצעות מילת המפתח `fn` (קיצור של function), שם הפונקציה (בראסט מקובל להשתמש ב snake_case, כלומר להפריד מילים באמצעות קו תחתון ולא במאצעות אותו גדולה), ורשימת הארגומנטים שהיא מקבל, בתוך הסוגריים. כיוון שבמקרה שלנו `main` לא מקבלת שום ארגומנטים, היא מכילה סוגריים רייקים. החלק האחרון בשורה הראשונה הוא סוגריים מסולסלים, שפותחים את טווח ההכרה, הסקופ, של הפונקציה.

השורה הבאה שלנו היא
```rust{numberLines: 2}
println!("Hellow, world!");
```
כאן אנו משתמשים ב*מקרו* (וגם על מקרואים אשתדל לכתוב עוד בהמשך) `!println`. מקרואים בראסט מזוהים באמצעות העובדה שלפני העברת הפרמטרים אליהם יש סימן קריאה. זו היא לא קונבנציה, בניגוד לשם של המקרו, אלא ממש דרישה של השפה שבקריאה למקרו יהיה שימוש ב־`!`. הפרמטר אותו העברנו למקרו הוא הטקסט שברצוננו לכתוב. ראסט משתמשת כברירת מחדל בקידוד [utf8](https://he.wikipedia.org/wiki/UTF-8), כלומר, ניתן להשתמש גם בעברית בתוך מחרוזות טקסט.

בשורה האחרונה אנו סוגרים את הבלוק שפתחתנו בשורה מספר 1.

נריץ את הפרויקט ע"י קריאה, שוב, לקרגו:
```shell{outputLines: 2-5}
cargo run
   Compiling hello_world v0.1.0 (/Users/assapir/private/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/hello_world`
Hello, world!
```
קרגו מבשר לנו כי הוא קימפל את התוכנה `hello_world` בגירסה 0.1.0 (זוכרים את ההגדרה בקובץ Cargo.toml?), בתצורה של `dev`, ללא אופטמיזציה ועם ["סימבולים"](https://en.wikipedia.org/wiki/Debug_symbol), כדי שאם נרצה לדבג, נוכל לעשות את זה. בשורה האחרונה: התוצאה של הריצה:

אם נסתכל היטב, נראה שנוספה לנו תיקיה נוספת, בשם `target`, שגיט מתעלם ממנה. שם נוצרים התוצרים השונים של הקומפילציה. הקובץ שאותנו מעניין יהיה תחת `target/debug`, ויהיה בשם של הפרויקט (כפי שהגדרנו בקובץ toml), ללא כל סיומת (במק או לינוקס) או עם סיומת exe בחלונות. את הקובץ הזה אנחנו יכולים להריץ לגמרי לבד:
```shell{outputLines: 2}
./target/debug/hello_world
Hello, world!
```

איזה יופי! תוכנה משלנו!


#### אם משהו לא עובד
יתכן מצב ובו נקבל שגיאה כאשר נריץ את קרגו, למשל:
```shell{outputLines: 2}
cargo run
error: no override and no default toolchain set
```
בשביל לתקן את זה נצטרך להתקין את ה toolchain המתאים:
```shell{outputLines: 2-3}
rustup install stable
...
info: default toolchain set to ...
```
